# vim 实用技巧

插件：
- commentary：用于注释，`\\\` 可注释一行
- textobj-entire：用于全选整个文件，`vae`
- rails.vim: 自动配置 `path` 选项，可以直接使用 `:find {filename}` 直接打开对应文件
- matchit.vim: 使得 `%` 可以用于成对的 XML 标签或者其他语言的某些关键字
- surround.vim: 成对添加或者修改匹配的符号，例如括号，双引号等等
- textobj-lastpat：通过 `i/` 文本对象查找匹配上次查找的对象
- visualstar：查找当前选中的文本
- Abolish.vim: 超级 substitude 命令
- qargs.vim: 类似于 `argdo`, 可以将 quickfix 中的文件批量执行命令
- ack.vim: 通过 `:ack` 进行类似 grep 的搜索

vim 最小配置

```.vimrc
set nocompatible
filetype plugin on
```

## vim 解决问题的方式

vim 中修改的理想范式：一键重复移动，一键重复修改
这要求我们：
- 减少无关的移动，通过一键命令替代等效的移动加编辑命令
- 尽可能构造可重复的修改

```
C -> c$
s -> cl
S -> ^C
I -> ^i
A -> $a
o -> A<CR>
O -> ko
```

## 普通模式

指定执行次数可以减少按键个数，但有时简单地重复执行某一命令，要比花时间去计算想执行多少次要更好

使用 10<C-a> 和 10<C-x> 可以找到光标后的第一个数字并且加 10 和减 10

操作符 + 操作对象 = 操作
- 自定义操作符：`:h :map-operator`
- 自定义操作对象：`:h omap-info`

## 插入模式

插入-普通模式：插入模式下 `<C-o>` 可以执行一次普通模式的命令，然后回到插入模式，应用：
- 输入的时候看不到下半屏的内容，此时可以 `<C-o>zz`
- 输入对称的括号的时候，可以 `() <C-o>i{some texts}`，不过好像还不如 `() <Esc> i`

插入模式中
- `<C-r>0` 可以插入最近 yank 内容
- `<C-r>=` 可以进入表达式寄存器，输入表达式后按 <CR> 将会计算结果并插入

## visual 模式

`gv` 重复上次高亮区域
visual 模式下，按下 `o` 可以改变 visual 块的端点

使用 `.` 可以重复执行面向 `V` 的命令，比如 `V` 选中了多行，通过 `>` 进行缩进之后，可以通过 `.` 再次对上次的行进行缩进

如果想让 `.` 命令重复一些工作，最好远离 visual 模式。当然，visual 模式有其用武之地，比如有些操作对象很难直接表示，可以用 visual 模式进行框选。

通过 `<C-v>A` 可以实现在不同长度的行尾添加东西

visual 模式下，`i` 和 `a` 用于表示文本对象，所以不能用来插入

## Ex 模式

操作缓冲区文本的 Ex 命令：
- `:[range]delete [x]` 删除指定范围的行[保存到寄存器 x 中]
- `:[range]yank [x]` 复制指定范围的行[保存到寄存器 x 中]
- `:[line]put [x]` 在指定范围的行后面粘贴寄存器 x 中的内容
- `:[range]copy {address}` 把指定范围的行拷贝到 {address} 所指定的行之下
- `:[range]move {address}` 把指定范围的行移动到 {address} 所指定的行之下
- `:[range]join` 连接指定范围的行
- `:[range]normal {commands}` 对指定范围的行执行一遍命令
- `:[range]substitute/{pattern}/{string}/[flags]` 把指定范围出现 {pattern} 的地方替换为{string}
- `:[range]global/{pattern}/[cmd]` 对指定范围出现 {pattern} 的所有行，在其上执行 Ex 命令{cmd}
其中 {range}, {address} 可以是行号、位置标记以及查找的 pattern，以及对它们的偏移
- `l` 表示文件的第一行
- `$` 表示文件的最后一行
- `0` 表示虚拟行，是文件第一行上方的一行
- `.` 表示光标所在行
- `'m` 表示位置标记 m 所在的行
- `'<` 表示高亮区起始行
- `'>` 表示高亮区结束行
- `%` 表示整个文件的所有行

可以先通过 `V` 选中需要操作的行，然后通过 `:` 对所在的行执行 Ex 命令
Ex 命令的范围也可以通过 pattern 来指定 `:/pattern1/,/pattern2/`

Ex 命令模式支持插入模式中的组合键，比如
- `<C-r>{register}` 来粘贴寄存器中的文本
- `<C-r>=` 来计算表达式
- `<C-r><C-w>` 来插入当前光标下的 word

通过 Ex 命令 `:[range] normal .` 可以重复大量操作，比如在指定范围的每一行添加分号；对于复杂命令，可以使用 `:[range] normal @q` 对多行文本进行批量宏处理

通过 `@:` 可以执行上一条 Ex 命令，比如在多个 buffer 之间跳转 `:bnext`，执行一次之后，只需要 `@@` 就可以重复上一次的宏命令

通过 `:set wildmode=longest,list` 可以获得类似 bash 的自动补全的体验

通过 `q:` 可以调出命令行历史窗口

假设在 Ex 命令输入过程中需要打开命令行窗口以拥有更强的编辑能力，可以通过 <C-f> 调出命令行窗口，并使当前已经输入的命令得以保存

在 Ex 中执行 shell 命令时，`%` 表示当前文件名，执行多条 shell 命令时，可以使用 `:shell` 或者终端命令 `<C-z>` 挂起任务并使用 `jobs` 和 `fg` 恢复 vim
在 Ex 中执行 `:read !{cmd}` 时会将命令执行的结果读入当前光标位置，相反，如果 `:write !{cmd}` 则会将当前缓冲区的每行内容作为 cmd 的输入，比如 `:write !sh` 将会在 shell 中执行每一行命令
在 Ex 中执行 `:[range]!{cmd}` 则以当前 [range] 指定的作为输入，调用 cmd 之后将输出放回 [range] 中，比如调用外部的 sort 进行对指定行进行排序 `:2,$!sort -t',' -k2`，Vim 提供了一种更加方便的快捷键进行范围指定，在 normal 模式下 `!G` 就会把 `:.,$!` 预置在 Ex 命令行上

## 管理多个文件

缓冲区命令：
- `:ls`
- `:bnext`
- `:bprev`
- `:bfirst`
- `:blast`
- `:buffer {bufname}`: 通过指定名字跳到对应的 buffer，可使用 <tab> 进行补全
- `:bufdo`: 对 `:ls` 列出的所有 buffer 执行 Ex 命令
- `:bdelete {bufname}`

利用参数列表对 buffer 进行分组：
- `:args`
- `:args {arglist}`: 通过 {arglist} 修改当前参数列表，可以使用通配符
    - `*` 匹配 0 或多个字符
    - `**` 匹配 0 或多个字符，并且包括子目录
- `:args `cat .chapters``: 通过文件 .chapters 维护一个文件名列表，通过反引号 `cat .chapters` 作为 `:args` 的输入，可以方便管理参数列表
- `next`
- `prev`
- `argdo {cmd}`: 对 `:args` 列出的所有文件执行 Ex 命令

使用 `:argdo` 或 `:cmddo` 时，有可能出现
- `:first`
- `:{cmd}`
- `:next`
- `:{cmd}`
正常情况下，如果修改了其中一个 buffer，要切换到其他 buffer 之前需要使用 `!`，比如 `:next!` 将当前的 buffer 设为 hidden buffer，如果不想使用 `!`，可以 `:set hidden`

关闭窗口：
- `:close`
- `:only`

Vim 的标签页不同于其他文本编辑器，可以将它理解为容纳多个窗口的容器，它更像是 Linux 中的虚拟桌面，用于把工作分割到不同的工作区，比如，当我们突然接到一个紧急任务，又不想弄乱当前的布局，那么就可以考虑创建新的标签页，准备做回原来工作的时候又切换回去原来的标签页
`:lcd {path}` 命令可以设置当前窗口的本地工作目录，如果创建一个新的标签页并且希望所有标签页一同切换，可以使用 `:windo lcd {path}` 或者 `:tcd {path}` 为所有窗口设置
tab 的操作：
- `:tabedit`
- `:tabclose`
- `:tabonly`
- `<C-w>T`: 把当前的窗口移动到一个新的 tab
- `tabnext {N}` 等价于 `{N}gt`
- `tabprev {N}` 等价于 `{N}gT`

## 打开及保存文件

使用 `:set path+=app/**` 可以将某个目录及其子目录添加到变量 `path` 中，后续通过 `:find {filename}` 打开对应文件

netrw 文件管理器：
使用 `:E` 可以打开 netrw 文件管理器
使用 `:Se` 可以水平分窗口并打开 netrw 文件管理器
使用 `:Ve` 可以垂直分窗口并打开 netrw 文件管理器

## 用动作命令在文档中移动

多用 `f` 和查找进行移动，少用 `hjkl`

`j`, `k` 按照实际行移动，`gj`, `gk` 按照屏幕行移动，`g0` `g$` `g^` 同理

使用搜索进行跳转时，可以启用 `:set incsearch` 找到第一个匹配的地方

相比于 `v/{word}hd`，`d/{word}` 可以更快地通过查找删除到对应的位置，原因是查找命令是一个开动作（开闭区间），这样选中的 {word} 会被排除在外

vim 自动标记的位置：
- ````: 当前文件中上次跳转的位置
- ``.`: 上次修改的位置
- ``^`: 上次插入的位置
- ``[`: 上次修改或复制的起始位置
- ``]`: 上次修改或复制的结束位置
- ``<`: 上次高亮的起始位置
- ``>`: 上次高亮的结束位置
通过 `:marks` 可以打印所有的标记

利用 `%` 可以进行匹配的符号（例如括号）的跳转，但是当我们需要修改成对的括号的时候，如果先修改了左边，就导致没法快速通过 `%` 号修改右边，我们有一个技巧，先通过 `%` 跳到右边的括号，再通过 ```` 或者 `<C-o>` 返回上一个光标处

通过在 `.vimrc` 中 `runtime macros/matchit.vim` 后，可以通过 `Va%` 选中匹配括号的段落，用来折叠代码或者删除非常方便

## 在文件间跳转

可以通过 `:jumps` 查看跳转列表的内容，每个窗口维护一个跳转列表

可以通过 `:changes` 查看修改列表的内容，通过 `g;` 和 `g,` 来前后跳转

可以通过 `gf` 跳转到光标下的文件

可以使用 `m{LETTER}` 来设置全局标签。考虑这么一种情况，我们使用 vimgrep 查找某个函数的定义时出现了多个定义，我们在 quickfix 列表中不断遍历，最终找到想要的定义，这个时候如果想退回去原来调用的地方，显然需要按很多下 `<C-o>`，但是使用全局标记可以立马跳回去

## 复制与粘贴

通过 `xp` 可以实现光标之后的两个字符的对调
通过 `ddp` 可以实现光标所在行之后的两行的对调

`:registers` 和 `:reg` 可以显示所有寄存器的内容

使用默认寄存器可能会出现一种情况，当你 `yiw` 复制了一个单词之后，想通过 `diw` 删除另外一个单词并且 `p`，会把 `yiw` 的内容弄丢，原因是 vim 中的 `diw` 实际上不仅仅是删除，而是剪切，所以会将默认的寄存器覆盖。
要解决上述问题，需要通过 `"ayiw` 将单词复制到寄存器 a，再 `"ap` 来将寄存器 a 的内容粘贴出来

使用 `:delete c` 可以将当前行剪切到寄存器 c 中，再执行 `:put c` 将寄存器 c 中的内容粘贴，这可以用于和其他 Ex 命令结合使用，或者编写 Vim 脚本

使用无名寄存器 `""p` 等同于 `p`，以下操作都会覆盖无名寄存器：
- `x`
- `d{motion}`
- `c{motion}`
- `s`

复制专用寄存器 `"0` 只会被 `y{motion}` 覆盖，可以使用 `"0p` 来粘贴

用小写字母引用寄存器，会覆盖原来寄存器的内容；用大写字母会追加

系统寄存器 `"+` 可以用于 vim 和系统交换信息，包括系统剪贴板到 vim 或者 vim 到系统剪切板，比如将 `"+yiw` 可以复制一个单词到系统剪板
并且使用 `"+` 可以不必担心系统粘贴带来的缩进问题

其他寄存器:
- `"%`: 当前文件名
- `"#`: 轮换文件名
- `".`: 上次插入的文本
- `":`: 上次执行的 Ex 命令
- `"/`: 上次查找的模式

使用 `viw` 之后 `p` 可以避免 `diw` 或者 `ciw` 对无名寄存器的覆盖，因为 `p` 才会将被替换的内容放入无名寄存器
利用 `vp` 操作可以对调两个 word，先对 word1 `diw`，然后 `v` 选中 word2，之后 `p`, 然后 ```` 回到原来的位置 `p` 即可

## 宏

通过 `q{register}` 录制宏之后，可以通过 `:reg` 查看寄存器，通过 `@{register}` 来重放宏
配合 `V:` 和 `normal @{register}` 可以对多行执行宏

`@@` 可以重放最近调用的宏

对于 `;.` 范式，如果我们想重复 10 次，不能用 `10;.` 或者 `;10.`，因为 `10;.` 会触发 10 次 `;` 和一次 `.`，`;10.` 同理，正确的方法应当是 `qq;.q` 然后 `10@q`

对于宏操作，有时候不需要具体计算执行的次数，可以直接给定一个比较大的次数，执行足够次数后，宏会因为无法执行而自动停止

当我们录制了一个处理一行文本的宏，然后在多行上播放，可以选择 `5@a`，但如果第 3 行不能满足宏执行的条件时，多行的宏会停止，这也叫做串行的宏
引入并行宏：`V` 选中多行，然后执行 `:normal @a` 则可以并行地在每一行执行宏，并且可以跳过不满足的行

使用大写字母可以向寄存器（已录制的宏）追加命令

`:args *.cpp` 和 `:argdo normal @a` 可以对多个文件进行宏操作，此为并行操作，若使用串行操作，则不用 `:argdo` 而用 `:next`
在操作多文件时，可以多使用串行的方法，因为多文件宏不像单文件那么一目了然

假如我们需要对每一行增加自增的编号，可以通过：
- `:let i=1` 在 Vim 中定义变量并且赋值
- `qa` 开始录制宏
- `I<C-r>=i)<Esc>` 在行首插入编号
- `:let i+=1` 使变量 `i` 自增
- `q` 结束录制宏
- `jVG` 选中余下的行
- `:'<,'>normal @a` 并行执行宏

录制的宏会保存在寄存器 {register} 中，可以通过粘贴 {register} 的内容在文本中编辑，然后在粘贴回去寄存器

## 按模式匹配，按原意匹配

`\c` 让本次查找忽略大小写，`\C` 让本次查找强制区分大小写

Vim 默认使用 Posix 风格的正则表达式进行查找

当我们希望使用 Perl 正则表达式进行查找时，可以使用 `\v` 开启 magic 模式，这样不需要对某些字符做转义
```
$ . * ~ () |
```

当我们希望使用原意进行查找时，可以使用 `\V`，这样特殊字符要生效都需要 `\` 进行转义

一个专门用来匹配重复单词的正则表达式 `/\v<(\w+)\_s+\1>`
- `<` 表示匹配单词左边界
- `>` 表示匹配单词右边界
- `\w+` 表示匹配一个或多个字符
- `\_s+` 表示匹配一个或多个空白符或者换行符
- `\1` 与前面的 `()` 组合使用，`\1` 表示引用 `()` 这段被捕获的文本。另外，使用 `%()` 可以仅进行匹配，而不进行捕获，捕获到的内容不会赋值给 `\1`，当存在大量 `()` 并且需要操作捕获内容时，使用 `%()` 可以不扰乱想要捕获的内容

通过 `<>` 来界定单词的边界，可以做到 whole word only 的搜索效果

使用 `*` 或者 `#` 默认会使用单词界定符，而 `g*` 和 `g#` 则不会使用

通过 `\zs` 和 `\ze` 可以在匹配的模式中仅仅高亮 `\zs` 到 `\ze` 的部分，比如 `Pratical \zsVim<CR>` 只会高亮 `Pratical` 后面的 `Vim`

使用 `\V` 之后大部分的符号的特殊含义被屏蔽了，比如 `.`, `*` 等等，但是仍然有一部分的字符需要虽然在前面 `\` 屏蔽它们的特殊含义：
- 正向查找时 `/` 需要转义，否则会被当成查找域的结束符
- 反向查找时 `?` 需要转义，否则会被当成查找域的结束符
- `\` 需要转义

人工转义非常麻烦，Vim 提供了函数 `escape({pattern},{char})` 用于转义，比如：
- 正向查找调用 `escape({@a,'/\'})`，其中 `@a` 是复制了 pattern 的寄存器
- 反向查找调用 `escape({@a,'?\'})`，其中 `@a` 是复制了 pattern 的寄存器
具体操作：
- `/\V`
- `<C-r>=` 进入赋值寄存器
- `escape(@a,'/\')<CR>` 调用函数
- `<CR>`

## 查找

通过 `nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>` 将 `<C-l>` 绑定为清除高亮并且清屏

开启 `incsearch` 之后，光标会自动跳转到第一个匹配的地方，此时可以利用 `<C-r><C-w>` 进行补全

`:%s///gn` 统计当前模式匹配的个数

`/{pattern}/e` 可以在查找后偏移到 {pattern} 的尾部

有时候需要对查找到的整个 pattern 做操作，比如将它们全部转换为大写，这个时候，可以 `gU//e<CR>`，其中 `//e` 表示跳转到上次查找的 pattern 的尾部，不过修改下一个匹配项的时候需要用 `//<CR>.` 来操作，因为 `n.` 会跳到 pattern 的尾部，再操作

## 替换

substitude 的语法：`:[range]s[ubstitude]/{pattern}/{string}/[flags]`

flags:
- `g`: 使得 substitute 修改当前行的所有匹配，而不仅仅是第一处
- `c`: 让我们可以确认每一处是否执行
- `n`: 只统计匹配个数，而不执行替换
- `e`: 屏蔽 substitude 的 error
- `&`: 重复上一次 substitute 所用过的标志位

替换域中的特殊字符：
- `\r`: 换行符
- `\t`: 制表符
- `\\`: 反斜杠
- `\1`: 第 1 个子匹配
- `\2`: 第 2 个子匹配
- `\0`: 匹配的所有内容
- `$`: 匹配的所有内容
- `~`: 上次 substitude 所用的 {string}
- `\={Vim Script}`: 执行 {Vim Script} 表达式，将结果替换 {string}

`%s/{pattern}/{string}/g` 可以替换整个文件
`%s/{pattern}/{string}/gc` 可以替换整个文件过程中，询问每一处是否执行

`:s//{string}` 忽略 {pattern} 时，使用上次的 {pattern}，在创建复杂的 {pattern} 时，将替换分为先查找再替换会更加高效

可以通过 `<C-r>{register}` 将寄存器的内容插入到命令行中，不过当包含特殊字符的时候，处理起来比较麻烦，因此可以使用 `:s//\=@0` 来引用寄存器 0，其中 `\=` 表示执行一段 {Vim Script}, `@0` 表示寄存器 0

当我们忘记在 `s` 前面添加 `%` 的时候，可以使用 `g&`，等价于 `%s//~/&`

`:&&` 重复上次的 substitute 命令，重复上次的标志位

重排 csv 文件的列顺序：
- `/\v^([^,]*),([^,]*),([^,]*)$`
- `:%s//\3,\2,\1`

替换多个单词：
- `/\v(<man>|<dog>)`
- `:%s//={"dog":"man","man","dog"}[submatch(1)]/g`

## `global` 命令

`global` 命令允许我们在匹配 {pattern} 的行上批量执行 Ex 命令

语法：`:[range] global[!] /{pattern}/ [cmd]`
- `[range]`: 默认为整个文件，即 `%` 而不是 `.`
- `{pattern}`: 留空时自动使用上一次的 `{pattern}`
- `[cmd]`: 默认为 :print，即打印当前行
- `global!` 或 `vglobal`: 表示反选，即在不匹配的行上执行命令

删除匹配行：
- `\v\<\/?\w+`
- `:g//d`

只保留匹配行：
- `:v/href/d`

将匹配行存储到寄存器中：
- `qaq` 清除寄存器 a
- `:g/TODO/yank A` 将匹配 TODO 的行逐个追加到寄存器 a 中
- `"ap` 将寄存器 a 的内容粘贴出来
或者：
- `:g/TODO/copy$` 将匹配 TODO 的行逐个追加到文件末尾

`:g/{pattern}/[range][cmd]` 以 `:g/{pattern}` 匹配为参考点，动态设置 [cmd] 对应的 [range]:
- `:g/{/ .+1,/}/-1 sort`
    - `.+1,/}/-1` 表示从当前行的下一行开始，直到匹配到 `}` 的上一行结束
    - `:g/{` 表示执行的 global 命令的 {pattern} 为 `}`
也就是 `:global` 的广义形式为 `:g/{start}/ .,{finish} [cmd]`

## ctags

ctags 的作用：
- 定义跳转
- 自动补全

ctags 生成的文件 tags 记录了每一个 tag 的文件名和位置（通过 `:/{pattern}` 的方式进行定位）

通过 `:set tags?` 可以查看 vim 查找 tags 文件的默认路径

通过 `autocmd` 或者 git 的回调自动更新 ctags

- 通过 `<C-]>` 进行跳转后可以通过 `<C-t>` 进行后退
- 通过 `g<C-]>` 可以选择跳到多个匹配的定义
可以使用 Ex 命令进行 tag 跳转：
- `:tag {keyword}` 相当于 `<C-]>`
- `:tjump {keyword}` 相当于 `g<C-]>`
这种方式还支持自动补全，只需要输入 tag 的前半段就可以自动补全，
还可以通过 `:tjump /{pattern}` 正则表达式查看

## quickfix

quickfix 与 make, grep 等工具配合使用，可以将命令执行后的结果显示到 quickfix 列表中

在 Vim 中执行 `:make` 后，如果有编译错误，可以通过 `:copen` 打开 quickfix 列表：
- `:cnext` 跳转到下一项
- `:cprev` 跳转到上一项
`:lmake` 与 `:make` 类似，不同点在于 `:lmake` 会在不同的窗口下生成 quickfix 列表

`:colder` 和 `:cnewer` 可以回溯到 quickfix 列表之前的某个版本，比如执行过 `:make` 和 `:grep`，我们不需要再次执行 `make` 而应该执行 `:colder` 来拿到 `:make` 的结果

通过一定的配置，可以使 `:make` 调用其他外部工具

## grep, vimgrep

vimgrep 可以保证正则语法与 Vim 自带的查找引擎一致，但查找速度几乎不可能达到专用程序的水平

通过一定的配置，可以使 `:grep` 调用其他外部工具，比如 ack

## 自动补全

插入模式下，`<C-p>` 或者 `<C-n>` 会出发自动补全

自动补全菜单弹出后的操作：
- `C-y` 选中当前项（yes）
- `C-e` 退出自动补全（exit）

小技巧：使用 `<C-p><C-n>` 可以触发自动补全并且保留回退到当前输入的字符

更小粒度的补全：
- `<C-x><C-n>`: 当前 buffer 关键字
- `<C-x><C-i>`: 包含文件关键字
- `<C-x><C-]>`: 标签文件关键字
- `<C-x><C-k>`: 字典查找，需要为 Vim 提供一份合适的单词列表，比如 `:set spell` 激活拼写检查功能
- `<C-x><C-l>`: 整行补全
- `<C-x><C-f>`: 文件名补全
- `<C-x><C-o>`: 全能补全（Omni），即 intellsense



